// library.cpp
// C++17 console-based Library Management System with CSV storage
// Features: Book DB, Search, Checkout, Return, Fine Calculation, Console UI

#include <iostream>
#include <iomanip>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <ctime>
#include <cctype>
#include <limits>
#include <optional>

using namespace std;

// ----------------------------- Config -----------------------------
static const string BOOKS_FILE = "books.csv";
static const string BORROWERS_FILE = "borrowers.csv";
static const string TRANSACTIONS_FILE = "transactions.csv";
static const int FINE_RATE_PER_DAY = 10; // currency units per day
static const int DEFAULT_LOAN_DAYS = 14;

// ----------------------------- Utilities -----------------------------
string trim(const string& s) {
    size_t start = s.find_first_not_of(" \t\r\n");
    if (start == string::npos) return "";
    size_t end = s.find_last_not_of(" \t\r\n");
    return s.substr(start, end - start + 1);
}

string toLower(string s) {
    transform(s.begin(), s.end(), s.begin(), [](unsigned char c){ return std::tolower(c); });
    return s;
}

bool icontains(const string& hay, const string& needle) {
    return toLower(hay).find(toLower(needle)) != string::npos;
}

vector<string> splitCSV(const string& line) {
    vector<string> fields;
    string field;
    bool inQuotes = false;
    for (size_t i = 0; i < line.size(); ++i) {
        char c = line[i];
        if (c == '"') {
            inQuotes = !inQuotes;
        } else if (c == ',' && !inQuotes) {
            fields.push_back(field);
            field.clear();
        } else {
            field.push_back(c);
        }
    }
    fields.push_back(field);
    for (auto& f : fields) f = trim(f);
    return fields;
}

string escapeCSV(const string& s) {
    bool needQuotes = s.find_first_of(",\"\n\r") != string::npos;
    string out = s;
    size_t pos = 0;
    while ((pos = out.find('"', pos)) != string::npos) {
        out.insert(pos, 1, '"');
        pos += 2;
    }
    if (needQuotes) return "\"" + out + "\"";
    return out;
}

// ----------------------------- Date helpers -----------------------------
struct Date {
    int year{0}, month{0}, day{0}; // YYYY-MM-DD
};

bool parseDate(const string& s, Date& d) {
    // Expect YYYY-MM-DD
    if (s.size() != 10 || s[4] != '-' || s[7] != '-') return false;
    try {
        d.year = stoi(s.substr(0,4));
        d.month = stoi(s.substr(5,2));
        d.day = stoi(s.substr(8,2));
    } catch (...) { return false; }
    if (d.month < 1 || d.month > 12 || d.day < 1 || d.day > 31) return false;
    return true;
}

string formatDate(const Date& d) {
    ostringstream oss;
    oss << setw(4) << setfill('0') << d.year << "-"
        << setw(2) << setfill('0') << d.month << "-"
        << setw(2) << setfill('0') << d.day;
    return oss.str();
}

Date todayDate() {
    time_t now = time(nullptr);
    tm* lt = localtime(&now);
    Date d;
    d.year = lt->tm_year + 1900;
    d.month = lt->tm_mon + 1;
    d.day = lt->tm_mday;
    return d;
}

int daysBetween(const Date& a, const Date& b) {
    // returns (a - b) in days
    tm ta = {};
    ta.tm_year = a.year - 1900;
    ta.tm_mon = a.month - 1;
    ta.tm_mday = a.day;
    ta.tm_isdst = -1;

    tm tb = {};
    tb.tm_year = b.year - 1900;
    tb.tm_mon = b.month - 1;
    tb.tm_mday = b.day;
    tb.tm_isdst = -1;

    time_t t_a = mktime(&ta);
    time_t t_b = mktime(&tb);
    if (t_a == -1 || t_b == -1) return 0;
    double diff = difftime(t_a, t_b) / (60*60*24);
    return (int)diff;
}

Date addDays(const Date& d, int days) {
    tm t = {};
    t.tm_year = d.year - 1900;
    t.tm_mon = d.month - 1;
    t.tm_mday = d.day;
    t.tm_isdst = -1;
    time_t tt = mktime(&t);
    tt += days * 24 * 60 * 60;
    tm* nt = localtime(&tt);
    Date nd;
    nd.year = nt->tm_year + 1900;
    nd.month = nt->tm_mon + 1;
    nd.day = nt->tm_mday;
    return nd;
}

// ----------------------------- Data models -----------------------------
struct Book {
    int id{0};
    string title;
    string author;
    string isbn;
    bool available{true};
};

struct Borrower {
    int id{0};
    string name;
    string contact;
};

struct Transaction {
    int id{0};
    int book_id{0};
    int borrower_id{0};
    Date checkout_date{};
    Date due_date{};
    optional<Date> return_date; // empty if not returned
};

// ----------------------------- Library class -----------------------------
class Library {
public:
    void load() {
        loadBooks();
        loadBorrowers();
        loadTransactions();
    }
    void save() {
        saveBooks();
        saveBorrowers();
        saveTransactions();
    }

    // ---- Books ----
    void listBooks() const {
        cout << "\n-- Books --\n";
        cout << left << setw(5) << "ID" << setw(30) << "Title" << setw(22) << "Author"
             << setw(16) << "ISBN" << setw(12) << "Status" << "\n";
        cout << string(85, '-') << "\n";
        for (const auto& b : books) {
            cout << left << setw(5) << b.id
                 << setw(30) << truncate(b.title, 29)
                 << setw(22) << truncate(b.author, 21)
                 << setw(16) << truncate(b.isbn, 15)
                 << setw(12) << (b.available ? "Available" : "Checked out")
                 << "\n";
        }
    }

    void addBook() {
        Book b;
        b.id = nextBookId();
        cout << "Enter title: "; getlineSafe(b.title);
        cout << "Enter author: "; getlineSafe(b.author);
        cout << "Enter ISBN: "; getlineSafe(b.isbn);
        if (b.title.empty() || b.author.empty() || b.isbn.empty()) {
            cout << "Error: all fields are required.\n";
            return;
        }
        if (findBookByISBN(b.isbn)) {
            cout << "Error: ISBN already exists.\n";
            return;
        }
        b.available = true;
        books.push_back(b);
        saveBooks();
        cout << "Book added (ID " << b.id << ").\n";
    }

    void searchBooks() const {
        cout << "Search by keyword (title, author, or ISBN): ";
        string q; getlineSafe(q);
        if (q.empty()) {
            cout << "Empty query.\n"; return;
        }
        cout << left << setw(5) << "ID" << setw(30) << "Title" << setw(22) << "Author"
             << setw(16) << "ISBN" << setw(12) << "Status" << "\n";
        cout << string(85, '-') << "\n";
        int count = 0;
        for (const auto& b : books) {
            if (icontains(b.title, q) || icontains(b.author, q) || icontains(b.isbn, q)) {
                cout << left << setw(5) << b.id
                     << setw(30) << truncate(b.title, 29)
                     << setw(22) << truncate(b.author, 21)
                     << setw(16) << truncate(b.isbn, 15)
                     << setw(12) << (b.available ? "Available" : "Checked out")
                     << "\n";
                count++;
            }
        }
        if (count == 0) cout << "No matches.\n";
    }

    // ---- Borrowers ----
    void listBorrowers() const {
        cout << "\n-- Borrowers --\n";
        cout << left << setw(5) << "ID" << setw(30) << "Name" << setw(28) << "Contact" << setw(18) << "Active Loans" << "\n";
        cout << string(90, '-') << "\n";
        for (const auto& br : borrowers) {
            cout << left << setw(5) << br.id
                 << setw(30) << truncate(br.name, 29)
                 << setw(28) << truncate(br.contact, 27)
                 << setw(18) << activeLoansFor(br.id)
                 << "\n";
        }
    }

    void addBorrower() {
        Borrower br;
        br.id = nextBorrowerId();
        cout << "Enter borrower name: "; getlineSafe(br.name);
        cout << "Enter contact: "; getlineSafe(br.contact);
        if (br.name.empty()) {
            cout << "Error: name required.\n"; return;
        }
        borrowers.push_back(br);
        saveBorrowers();
        cout << "Borrower added (ID " << br.id << ").\n";
    }

    // ---- Transactions ----
    void listTransactions() const {
        cout << "\n-- Transactions --\n";
        cout << left << setw(5) << "ID" << setw(24) << "Book"
             << setw(20) << "Borrower" << setw(12) << "Checkout"
             << setw(12) << "Due" << setw(12) << "Return" << setw(10) << "Fine" << "\n";
        cout << string(95, '-') << "\n";
        for (const auto& t : transactions) {
            const Book* b = findBookById(t.book_id);
            const Borrower* br = findBorrowerById(t.borrower_id);
            int fine = calculateFine(t);
            cout << left << setw(5) << t.id
                 << setw(24) << truncate(b ? b->title : "?", 23)
                 << setw(20) << truncate(br ? br->name : "?", 19)
                 << setw(12) << formatDate(t.checkout_date)
                 << setw(12) << formatDate(t.due_date)
                 << setw(12) << (t.return_date.has_value() ? formatDate(t.return_date.value()) : "—")
                 << setw(10) << fine
                 << "\n";
        }
    }

    void checkoutBook() {
        int bookId, borrowerId;
        cout << "Enter book ID to checkout: "; if (!readInt(bookId)) return;
        Book* b = findBookByIdMutable(bookId);
        if (!b) { cout << "Book not found.\n"; return; }
        if (!b->available) { cout << "Book is not available.\n"; return; }

        cout << "Enter borrower ID: "; if (!readInt(borrowerId)) return;
        Borrower* br = findBorrowerByIdMutable(borrowerId);
        if (!br) { cout << "Borrower not found.\n"; return; }

        int loanDays = DEFAULT_LOAN_DAYS;
        cout << "Loan days (default " << DEFAULT_LOAN_DAYS << "): ";
        string inp; getlineSafe(inp);
        if (!inp.empty()) {
            try { loanDays = stoi(inp); } catch (...) { loanDays = DEFAULT_LOAN_DAYS; }
            if (loanDays < 1) loanDays = DEFAULT_LOAN_DAYS;
        }

        Transaction t;
        t.id = nextTransactionId();
        t.book_id = b->id;
        t.borrower_id = br->id;
        t.checkout_date = todayDate();
        t.due_date = addDays(t.checkout_date, loanDays);
        t.return_date.reset();

        transactions.push_back(t);
        b->available = false;
        saveBooks();
        saveTransactions();

        cout << "Checked out. Transaction ID " << t.id
             << ", due " << formatDate(t.due_date) << ".\n";
    }

    void returnBook() {
        int transactionId;
        cout << "Enter transaction ID to mark return: "; if (!readInt(transactionId)) return;
        Transaction* t = findTransactionByIdMutable(transactionId);
        if (!t) { cout << "Transaction not found.\n"; return; }
        if (t->return_date.has_value()) { cout << "Already returned.\n"; return; }

        t->return_date = todayDate();
        Book* b = findBookByIdMutable(t->book_id);
        if (b) b->available = true;

        saveBooks();
        saveTransactions();

        int fine = calculateFine(*t);
        cout << "Returned on " << formatDate(t->return_date.value())
             << ". Fine: " << fine << ".\n";
    }

    void showFineForTransaction() const {
        int transactionId;
        cout << "Enter transaction ID: "; if (!readInt(transactionId)) return;
        const Transaction* t = findTransactionById(transactionId);
        if (!t) { cout << "Transaction not found.\n"; return; }
        int fine = calculateFine(*t);
        cout << "Fine for transaction " << transactionId << ": " << fine << ".\n";
    }

private:
    vector<Book> books;
    vector<Borrower> borrowers;
    vector<Transaction> transactions;

    // ---- Persistence ----
    void loadBooks() {
        books.clear();
        ifstream in(BOOKS_FILE);
        string line;
        // header: id,title,author,isbn,available
        while (getline(in, line)) {
            auto fields = splitCSV(line);
            if (fields.size() < 5) continue;
            Book b;
            try {
                b.id = stoi(fields[0]);
                b.title = fields[1];
                b.author = fields[2];
                b.isbn = fields[3];
                b.available = (fields[4] == "1" || toLower(fields[4]) == "true");
                books.push_back(b);
            } catch (...) { /* skip malformed */ }
        }
    }

    void saveBooks() const {
        ofstream out(BOOKS_FILE, ios::trunc);
        for (const auto& b : books) {
            out << b.id << ","
                << escapeCSV(b.title) << ","
                << escapeCSV(b.author) << ","
                << escapeCSV(b.isbn) << ","
                << (b.available ? "1" : "0") << "\n";
        }
    }

    void loadBorrowers() {
        borrowers.clear();
        ifstream in(BORROWERS_FILE);
        string line;
        // header: id,name,contact
        while (getline(in, line)) {
            auto fields = splitCSV(line);
            if (fields.size() < 3) continue;
            Borrower br;
            try {
                br.id = stoi(fields[0]);
                br.name = fields[1];
                br.contact = fields[2];
                borrowers.push_back(br);
            } catch (...) { /* skip */ }
        }
    }

    void saveBorrowers() const {
        ofstream out(BORROWERS_FILE, ios::trunc);
        for (const auto& br : borrowers) {
            out << br.id << ","
                << escapeCSV(br.name) << ","
                << escapeCSV(br.contact) << "\n";
        }
    }

    bool parseDateField(const string& s, optional<Date>& od) {
        string ts = trim(s);
        if (ts.empty() || ts == "-" || ts == "—") { od.reset(); return true; }
        Date d;
        if (!parseDate(ts, d)) return false;
        od = d; return true;
    }

    void loadTransactions() {
        transactions.clear();
        ifstream in(TRANSACTIONS_FILE);
        string line;
        // header: id,book_id,borrower_id,checkout,due,return
        while (getline(in, line)) {
            auto fields = splitCSV(line);
            if (fields.size() < 6) continue;
            Transaction t;
            try {
                t.id = stoi(fields[0]);
                t.book_id = stoi(fields[1]);
                t.borrower_id = stoi(fields[2]);
                Date cd, dd;
                if (!parseDate(fields[3], cd)) continue;
                if (!parseDate(fields[4], dd)) continue;
                t.checkout_date = cd;
                t.due_date = dd;
                optional<Date> rd;
                if (!parseDateField(fields[5], rd)) continue;
                t.return_date = rd;
                transactions.push_back(t);
            } catch (...) { /* skip */ }
        }
    }

    void saveTransactions() const {
        ofstream out(TRANSACTIONS_FILE, ios::trunc);
        for (const auto& t : transactions) {
            out << t.id << ","
                << t.book_id << ","
                << t.borrower_id << ","
                << formatDate(t.checkout_date) << ","
                << formatDate(t.due_date) << ","
                << (t.return_date.has_value() ? formatDate(t.return_date.value()) : "")
                << "\n";
        }
    }

    // ---- ID helpers ----
    int nextBookId() const {
        int mx = 0; for (const auto& b : books) mx = max(mx, b.id); return mx + 1;
    }
    int nextBorrowerId() const {
        int mx = 0; for (const auto& br : borrowers) mx = max(mx, br.id); return mx + 1;
    }
    int nextTransactionId() const {
        int mx = 0; for (const auto& t : transactions) mx = max(mx, t.id); return mx + 1;
    }

    // ---- Finders ----
    const Book* findBookByISBN(const string& isbn) const {
        for (const auto& b : books) if (b.isbn == isbn) return &b; return nullptr;
    }
    const Book* findBookById(int id) const {
        for (const auto& b : books) if (b.id == id) return &b; return nullptr;
    }
    Book* findBookByIdMutable(int id) {
        for (auto& b : books) if (b.id == id) return &b; return nullptr;
    }
    const Borrower* findBorrowerById(int id) const {
        for (const auto& br : borrowers) if (br.id == id) return &br; return nullptr;
    }
    Borrower* findBorrowerByIdMutable(int id) {
        for (auto& br : borrowers) if (br.id == id) return &br; return nullptr;
    }
    const Transaction* findTransactionById(int id) const {
        for (const auto& t : transactions) if (t.id == id) return &t; return nullptr;
    }
    Transaction* findTransactionByIdMutable(int id) {
        for (auto& t : transactions) if (t.id == id) return &t; return nullptr;
    }

    int activeLoansFor(int borrowerId) const {
        int c = 0;
        for (const auto& t : transactions)
            if (t.borrower_id == borrowerId && !t.return_date.has_value()) c++;
        return c;
    }

    // ---- Fine calc ----
    int calculateFine(const Transaction& t) const {
        Date ref = t.return_date.has_value() ? t.return_date.value() : todayDate();
        int overdueDays = daysBetween(ref, t.due_date);
        if (overdueDays <= 0) return 0;
        return overdueDays * FINE_RATE_PER_DAY;
    }

    // ---- IO helpers ----
    static void getlineSafe(string& out) {
        getline(cin, out);
        out = trim(out);
    }
    static bool readInt(int& v) {
        string s; getlineSafe(s);
        if (s.empty()) return false;
        try { v = stoi(s); return true; } catch (...) { cout << "Invalid number.\n"; return false; }
    }
    static string truncate(const string& s, size_t n) {
        if (s.size() <= n) return s;
        if (n < 3) return s.substr(0, n);
        return s.substr(0, n-3) + "...";
    }
};

// ----------------------------- UI -----------------------------
void printMenu() {
    cout << "\n========== Library Management ==========\n";
    cout << "1. List books\n";
    cout << "2. Add book\n";
    cout << "3. Search books\n";
    cout << "4. List borrowers\n";
    cout << "5. Add borrower\n";
    cout << "6. Checkout book\n";
    cout << "7. Return book\n";
    cout << "8. List transactions\n";
    cout << "9. Show fine for transaction\n";
    cout << "0. Exit\n";
    cout << "Select an option: ";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    Library lib;
    lib.load();

    while (true) {
        printMenu();
        string choiceStr; getline(cin, choiceStr);
        int choice = -1;
        try { choice = stoi(trim(choiceStr)); } catch (...) { choice = -1; }

        switch (choice) {
            case 1: lib.listBooks(); break;
            case 2: lib.addBook(); break;
            case 3: lib.searchBooks(); break;
            case 4: lib.listBorrowers(); break;
            case 5: lib.addBorrower(); break;
            case 6: lib.checkoutBook(); break;
            case 7: lib.returnBook(); break;
            case 8: lib.listTransactions(); break;
            case 9: lib.showFineForTransaction(); break;
            case 0:
                lib.save();
                cout << "Goodbye!\n";
                return 0;
            default:
                cout << "Invalid option. Try again.\n";
        }
    }
    return 0;
}
